#!/usr/bin/env python
#
# Copyright 2020 Troy Curtis, Jr.
#
# This file is part of gr-pager
#
# GNU Radio is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# GNU Radio is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU Radio; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street,
# Boston, MA 02110-1301, USA.
#

import argparse
import logging
import sys

from gnuradio import gr, filter, blocks
from gnuradio.eng_arg import eng_float

import osmosdr

import pager

logger = logging.getLogger("flex_band")

CHANNEL_SPACING_HZ = 25000
MAX_RTLSDR_BW_HZ = 2400000


class FlexBandApp(gr.top_block):
    def __init__(self, args):
        gr.top_block.__init__(self, "FlexBandApp")

        if args.input_type == "file":
            src = self.setup_file_input(args)
        elif args.input_type == "rtlsdr":
            src = self.setup_rtlsdr_input(args)
        else:
            logger.error("Unknown input type %s", args.input_type)
            sys.exit(1)

        self.message_debug = blocks.message_debug()

        # Setup the channelizer
        src_rate_hz, adj_chan = self.chan_to_bandwidth_hz(args.nchan)
        self.pfb_channelizer = filter.pfb.channelizer_ccf(adj_chan)
        # TODO: Set the channel map appropriately
        self.connect((src, 0), (self.pfb_channelizer, 0))

        lower_freq_hz = args.freq - (adj_chan/2 * CHANNEL_SPACING_HZ)
        channel_rate_hz = src_rate_hz / adj_chan
        self.receivers = []
        for i in range(adj_chan):
            self.receivers.append(pager.flex_receiver(lower_freq_hz + i * CHANNEL_SPACING_HZ, channel_rate_hz))
            self.connect((self.pfb_channelizer, i), (self.receivers[i], 0))
            self.msg_connect((self.receivers[i], 'pages'), (self.message_debug, 'print'))

    def setup_file_input(self, args):
        logger.info(
            "Reading input from file %(filename)s @ %(sample_rate)sHz", vars(args)
        )
        req_bw_hz, _ = self.chan_to_bandwidth_hz(args.nchan)
        if args.sample_rate < req_bw_hz:
            logger.error(
                "%s Hz bandwidth is required to support %d 25kHz channels, %s Hz input file is not enough. Please reduce the channel count.",
                req_bw_hz,
                args.nchan,
                args.sample_rate,
            )
            sys.exit(1)

        self.file_input = blocks.file_source(
            gr.sizeof_gr_complex * 1, args.input_file, False, 0, 0
        )

        if args.sample_rate != req_bw_hz:
            logger.warning(
                "Resampling input file from %s Hz to %s Hz, supply a file at the proper samplerate to eliminate wideband resampling.",
                args.sample_rate,
                req_bw_Hz,
            )
            self.arb_resamp = filter.pfb.arb_resampler_ccf(
                float(req_bw_hz) / args.sample_rate
            )
            self.connect((self.file_input, 0), (self.arb_resamp, 0))
            return self.arb_resamp

        return self.file_input

    def setup_rtlsdr_input(self, args):
        logger.info("Reading input from RTL SDR Dongle at %.3fMHz", args.freq / 1e6)
        req_bw_hz, _ = self.chan_to_bandwidth_hz(args.nchan)
        if req_bw_hz > MAX_RTLSDR_BW_HZ:
            logger.error(
                "%s 25kHz channels requires %s Hz of bandwidth which is more than the max supported bandwidth of %s for the RTL SDR dongle. Please reduce the channel count.",
                args.nchan,
                req_bw_hz,
                MAX_RTLSDR_BW_HZ,
            )
            sys.exit(1)

        self.rtlsdr_source = osmosdr.source(
            args="numchan=1 "
        )
        rtlsdr_sample_rate_hz = self.find_rtlsdr_sample_rate(self.rtlsdr_source, req_bw_hz)

        if not rtlsdr_sample_rate_hz:
            logger.error("Failed to find a supported RTL SDR sample rate to provide at least %s Hz bandwidth.", req_bw_hz)
            sys.exit(1)

        self.rtlsdr_source.set_time_unknown_pps(osmosdr.time_spec_t())
        self.rtlsdr_source.set_sample_rate(rtlsdr_sample_rate_hz)
        self.rtlsdr_source.set_center_freq(args.freq, 0)
        self.rtlsdr_source.set_freq_corr(0, 0)
        self.rtlsdr_source.set_dc_offset_mode(0, 0)
        self.rtlsdr_source.set_iq_balance_mode(0, 0)
        self.rtlsdr_source.set_gain_mode(args.rx_agc, 0)
        # self.rtlsdr_source.set_gain(rx_gain, 0)
        self.rtlsdr_source.set_if_gain(20, 0)
        self.rtlsdr_source.set_bb_gain(20, 0)
        self.rtlsdr_source.set_antenna("", 0)
        self.rtlsdr_source.set_bandwidth(0, 0)

        if rtlsdr_sample_rate_hz != req_bw_hz:
            logger.warning(
                "Resampling input data from %s Hz to %s Hz, supply a proper number of channels to eliminate wideband resampling.",
                rtlsdr_sample_rate_hz,
                req_bw_hz,
            )
            self.arb_resamp = filter.pfb.arb_resampler_ccf(
                float(req_bw_hz) / rtlsdr_sample_rate_hz
            )
            self.connect((self.rtlsdr_source, 0), (self.arb_resamp, 0))
            return self.arb_resamp

        return self.rtlsdr_source

    def find_rtlsdr_sample_rate(self, source, bw_hz):
        for rate_range in self.rtlsdr_source.get_sample_rates():
            # Commonly these will be equal start/stop values and step=0, so try the range but wrap
            # up by trying the `stop` value as well, before moving to the next range.
            rate = rate_range.start()
            while rate < rate_range.stop():
                if rate >= bw_hz:
                    return rate
                rate += rate_range.step()

            rate = rate_range.stop()
            if rate >= bw_hz:
                return rate

        return None

    def chan_to_bandwidth_hz(self, nchans):
        adj_channels = nchans
        return adj_channels * CHANNEL_SPACING_HZ, adj_channels


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Receive and decode FLEX Pager transmissions across a given band."
    )
    parser.add_argument("--verbose", "-v", action="store_true", default=False)
    parser.add_argument(
        "--log",
        "-l",
        action="store_true",
        default=False,
        help="log flowgraph data to files, producing a lot of data",
    )
    parser.add_argument(
        "--freq",
        "-f",
        type=eng_float,
        default=930.5125e6,
        help="Center frequency of the input, in Hz. (default=%(default)s)",
    )
    parser.add_argument(
        "--nchan",
        "-n",
        type=int,
        default=40,
        help="Number of channels to process. (default %(default)s)",
    )

    subparsers = parser.add_subparsers(dest="input_type")

    file_parser = subparsers.add_parser(
        "file",
        description="Read from a given file to get input data for flex pager decoding.",
        help="Read input data from a file.",
    )

    file_parser.add_argument(
        "filename", help="File containing raw complex floating point data to read from."
    )

    file_parser.add_argument(
        "sample_rate",
        type=int,
        help="The sample rate of the input file.",
    )

    rtl_parser = subparsers.add_parser(
        "rtlsdr", help="Read data from an RTLSDR USB dongle."
    )
    rtl_parser.add_argument(
        "--rx-agc",
        action="store_true",
        default=True,
        help="Enable Automatic Gain Control in the RTLSDR dongle.",
    )

    args = parser.parse_args()
    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)

    app = FlexBandApp(args)
    app.run()
